\documentclass{beamer}

\usepackage[frenchb]{babel}

\usepackage[T1]{fontenc}

\usepackage[latin1]{inputenc}


\usetheme{Warsaw}

% Debut - Rédaction du diaporama

\begin{document}

	\begin{frame}
	\frametittle{Parallel Scenario Decomposition of Risk Averse 0-1 Stochastic Programs}
    	% Une page de présentation
    	\end{frame}

        \begin{frame}
		\frametittle{Problématique}
            
            % Enoncé la problématique : traduire un peu la partie abstract de l'article
            Cette article traite d'une manière de passer des Algo de décomposition en scénario basé Risk Neutral 0-1 
            vers Risk-Avers 0-1

        \end{frame}
        
        \begin{frame}

            \frametitle{Problématique}
            % Expliquer la différence entre Risk-Neutral et Risk-Averse
           
        \end{frame}
        
        
        \begin{frame}
            \frametitle{Etat de l'art}
        \end{frame}
        
        \begin{frame}

            \frametitle{Approches/Méthodes Etudiées}
            	Scen -> méthode de déconpositon DD1 -> Le principe de l'algo est le suivant: On considère lambda = 0 pour la borne low. On set les bornes up -> +oo et low -> -oo S -> vide. Ensuite pour chaque vecteur, on calcule l'ensemble des solutions optimales Qu'on stock dans S de [min fk(x) x € X] pour les bornes données puis on met a jour la borne low en calculant la nouvelle borne avec g(0) ( noté Cont('b) ). Puis parmi toutes les solutions de S on calcul la borne supp comme étant le min de up et l'evaluation du probleme pour chaque xik. On répète l'opétation jusqu'à ce que l'écart entre low - up < un certain gap.
                
		DD2 -> Meme principe que DD1 sauf qu'on prend en compte la mise à jour des multiplicateurs Lagrangiens lambda. D'abords on initialise lambda à 0 , q à une certain valeur "p" (check later) et phi à +oo (q -> depend de la mesure coherent risk (rau), phi -> la solution du probleme stochastique) pour chaque vecteurs k = 1 à K, on résoud le sous probleme équivalent ce qui nous donne l'ensemble des solutions x^ et des valeurs objectives Bk. Ensuite on met à jour la borne low entre la valeur initiale (-oo) et la somme de toute les valeurs objectives. Ensuite on calcul le phi lambda et q  en se basant sur les solutions x^k récupérer. On répète la fonction jusqu'a ce que phi soit < à la somme des valeurs objectives calculées juste avant.
          
          
        \end{frame}
        
        \begin{frame}
        \frameTittle{Parallelisation stuff}
            Dans les trois différentes méthode vue précédemmebt, les opérations Scen() and Eval() sont effectuer une par une
            L'article avance 3 méthodes de paraléllisations de ces opérations : Basic Parallèle, With and Without Barrier            
            
            Dans les methode BP et WithBarier suivent un ordonancement de processus Type Round-Robin (ordre prédéfini) 
            alors que Without Barrier utilise un systeme de pull queue basic FIFO.
          
          
        \end{frame}
        
                \begin{frame}
        \frameTittle{Master-Worker Parallel with Barrier}
            Un processus maitre est désigné (Process N°n). Il se charge de mettre à jour bornes et les ensembles de solutions reçu des autres processeurs. Les autres N-1 processeurs se partagent le calcul de Scen et Eval
        \end{frame}
	
	
	\begin{frame}
          \frametitle{Basic Parallel}
	  On affecte K scenarios  a N processus Chaque processus resoud un sous probleme Scen(k) et evalue sa solution optimale.Le resultat de l'evaluation sert a  mettre a jour la limite supérieur un du proc n.On partage ensuite les résultats ce qui implique uune barrière a  chaque fois que le processus est pret a communiquer. Cet algo est faible aussi parce qu'il répète les solutions des scenarios.          
        \end{frame}
	
	
	\begin{frame}
	\frametitle{Master Worker sans barriere}
	Le fonctionnement de l'algo master worker sans barriere marche avec 2 files une de processus et une de tache. Il est initialisé au Scen pour les jobs et au processus pour les processus. Les processus reçoivent des taches : si c'es un Scen il le calcul en le beta k et le x^k au master. Le master reçoit k fois les resultats d'un scen puis il envoie le nouveau S au processeurs. Il calcul la borne max avec le cont Puis ajoute les Eval x^k au jobs a fair. Lorsque le master ajoute des Scen Ã  un proc il lui selectionne les S qu'il a a  supprimer de sa liste de solutions possibles.
        \end{frame}
	
        \begin{frame}

            Résultat

        \end{frame}
        
        \begin{frame}

	         Conclusion/Perspective

        \end{frame}

    % Fin de cette page de présentation


\end{document}

% Fin - Rédaction du diaporama
