\documentclass{beamer}

\usepackage[frenchb]{babel}

\usepackage[T1]{fontenc}

\usepackage[latin1]{inputenc}


% \usetheme{Warsaw}

% Debut - Rédaction du diaporama

\begin{document}


    % Une page de présentation

        \begin{frame}

            \frametittle{Problématique}
            
            % Enoncé la problématique : traduire un peu la partie abstract de l'article
            Cette article traite d'une manière de passer des Algo de décomposition en scénario basé Risk Neutral 0-1 
            vers Risk-Avers 0-1
            % Expliquer la différence entre Risk-Neutral et Risk-Averse

        \end{frame}
        
        \begin{frame}

            \frametitle{Problématique}
            
           

        \end{frame}
        
        
        \begin{frame}

            Etat de l'art

        \end{frame}
        
        \begin{frame}

            Approches/Méthodes Etudiées
            Scen -> méthode de déconpositon DD1 -> Le principe de l'algo est le suivant: On considère lambda = 0 pour
            la borne low.
            On set les bornes up -> +oo et low -> -oo S -> vide
            Ensuite pour chaque vecteur, on calcule l'ensemble des solutions optimales Qu'on stock dans S 
            de [min fk(x) x € X] pour les bornes données puis on met a jour la borne low en calculant la nouvelle borne
                avec g(0) ( noté Cont('b) ). Puis parmi toutes les solutions de S on calcul la borne supp
                comme étant le min de up et l'evaluation du probleme pour chaque xik. On répète l'opétation jusqu'à
                ce que l'écart entre low up < un certain gap.
                
                
                
                
          DD2 -> Meme principe que DD1 sauf qu'on prend en compte la mise à jour des multiplicateurs
          Lagrangiens lambda. D'abords on initialise lambda à 0 , q à une certain valeur "p" (check later)
          et phi à +oo (q -> depend de la mesure coherent risk (rau), phi -> la solution du probleme stochastique)
          pour chaque vecteurs k = 1 à K, on résoud le sous probleme équivalent ce qui nous donne 
          l'ensemble des solutions x^ et des valeurs objectives Bk. 
          Ensuite on met à jour la borne low entre la valeur initiale (-oo) et la somme de toute les valeurs objectives.
          Ensuite on calcul le phi lambda et q  en se basant sur les solutions x^k récupérer.
          On répète la fonction jusqu'a ce que phi soit < à la somme des valeurs objectives calculées juste avant.
          
          
        \end{frame}
        
        \begin{frame}
        \frameTittle{Parallelisation stuff}
            Dans les trois différentes méthode vue précédemmebt, les opérations Scen() and Eval() sont effectuer une par une
            L'article avance 3 méthodes de paraléllisations de ces opérations : Basic Parallèle, With and Without Barrier            
            
            Dans les methode BP et WithBarier suivent un ordonancement de processus Type Round-Robin (ordre prédéfini) 
            alors que Without Barrier utilise un systeme de pull queue basic FIFO.
          
          
        \end{frame}
        
                \begin{frame}
        \frameTittle{Master-Worker Parallel with Barrier}
            Un processus maitre est désigné (Process N°n). Il se charge de mettre à jour bornes et les ensembles de solutions reçu des autres processeurs. Les autres N-1 processeurs se partagent le calcul de Scen et Eval
            
          
          
        \end{frame}
        
        \begin{frame}

            Résultat

        \end{frame}
        
        \begin{frame}

	         Conclusion/Perspective

        \end{frame}

    % Fin de cette page de présentation


\end{document}

% Fin - Rédaction du diaporama
